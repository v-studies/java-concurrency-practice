# Section 11. CAS - 동기화와 원자적 연산

컴퓨터 과학에서 사용하는 **원자적** **연산**(atomic operation)의 의미는 해당 연산이 더 이상 나눌 수 없는 단위로 수행된다는 것을 의미한다.

즉, 원자적 연산은 중단되지 않고, 다른 연산과 간섭 없이 완전히 실행되거나 전혀 실행되지 않는 성질을 가지고 있다.

쉽게 이야기해서 멀티스레드 상황에서 다른 스레드의 간섭 없이 안전하게 처리되는 연산이라는 뜻이다.

```
volatile int i = 0;

// 원자적 연산
i = 1;

// 원자적 연산이 아니다
i = i + 1;
```

원자적 연산이 아닌 경우에는 `synchronized` 블럭이나 `Lock` 등을 사용해서 안전한 임계 영역을 만들어야 한다.

<br>

## 원자적연산 - AtomicInteger

자바에서 멀티스레드 상황에서 안전하게 증가 연산을 수행할 수 있는 `AtomicInteger` 라는 클래스를 제공한다. 

`AtomicInteger` 을 사용하면 synchronized, Lock(ReentrantLock)을 사용하는 경우보다 1.5 ~ 2배 정도 빠르다.

`i++` 연산은 원자적인 연산이 아니다. 따라서 분명히 `synchronized` , `Lock(ReentrantLock)` 와 같은 락을 통해 안전한 임계 영역을 만들어야 할 것 같다.

놀랍게도 `AtomicInteger` 가 제공하는 `incrementAndGet()` 메서드는 락을 사용하지 않고, 원자적 연산을 만들어낸다.

<br>

## CAS 연산

락 기반의 문제점은 락은 특정 자원을 보호하기 위해 스레드가 해당 자원에 대한 접근하는 것을 제한한다.

락이 걸려 있는 동안 다른 스레드들은 해당 자원에 접근할 수 없고, 락이 해제될 때까지 대기해야 한다.

락을 획득하고 반납하는 과정이 계속 반복된다. 10000번의 연산이 있다면 10000번의 연산 모두 같은 과정을 반복해야한다. 따라서 직관적이지만 상대적으로 무거운 방식이다.

이런 문제를 해결하기 위해 락을 걸지 않고 원자적인 연산을 수행할 수 있는 방법이 있는데, 이것을 **CAS(Compare-And-Swap, Compare-And-Set)** 연산이라 한다.

이 방법은 락을 사용하지 않기 때문에 `락 프리(lock-free)` 기법이라 한다. 참고로 CAS 연산은 락을 완전히 대체하는 것은 아니고, **작은 단위의 일부 영역**에 적용할 수 있다.

### CAS - 예제

값을 교체하는 cas 예제를 그림으로 확인해보자.

<img width="701" alt="Image" src="https://github.com/user-attachments/assets/828d259e-3b6d-414a-8592-67a03f6baa20" />

- 여기서는 AtomicInteger 내부에 있는 value 값이 0이라면 1로 변경하려 한다.
- 그런데 해당 명령어는 2개로 나누어진 명령이다. 따라서 원자적이지 않은 연산처럼 보인다.
    - 먼저 메인 메모리에 있는 값을 확인한다.
    - 해당 값이 기대하는 값(0)이라면 원하는 값(1)으로 변경한다.

CAS 연산은 이렇게 원자적이지 않은 두 개의 연산을 CPU 하드웨어 차원에서 특별하게 하나의 원자적인 연산으로 묶어서 제공하는 기능이다.


### AtomicInteger - incrementAndGet()

```java
private static int incrementAndGet(AtomicInteger atomicInteger) {
    int getValue;
    boolean result;
    do {
        getValue = atomicInteger.get();
        log("getValue: " + getValue);
        
        // 이 부분을 하드웨어에서 하나의 연산으로 처리한다.
        // 1. 메모리에 있는 값 확인
        // 2. 해당 값이 기대하는 값이라면 원하는 값으로 변경
        result = atomicInteger.compareAndSet(getValue, getValue + 1); 
        
        log("result: " + result);
    } while (!result);
    return getValue + 1;
}
```

- compareAndSet 이 부분이 CAS 연산이다.
- CAS는 메모리 위치에 있는 값이 기대한 값과 **정확히 일치**해야만 새 값으로 교체할 수 있는 연산이다.
- CAS는 성공할 수도 있고 실패할 수도 있기때문에 반복문이 필요하다. 이 과정을 반복하다가 성공(`true`)해야 최종적으로 `incrementAndGet`이 완수된다.

<br>


## CAS 락 구현

CAS는 단순한 연산 뿐만 아니라, 락을 구현하는데 사용할 수도 있다.

`synchronized`,`Lock(ReentrantLock)` 없이 CAS를 활용해서 락을 구현해보자.

예를들어 락을 획득하는 부분이 원자적이지 않고 두 부분으로 나뉘어서 실행된다

- 락 사용 여부 확인
- 락의 값 변경

```java
while(
  if (!lock) { // 1. 락 사용 여부 확인
    lock = true; // 2. 락의 값 변경
  }
)
```

이 둘은 한 번에 하나의 스레드만 실행해야 한다. 따라서 synchronized 또는 Lock을 사용해서 두 코드를 동기화해서 안전한 임계 영역을 만들어야 한다.

여기서 다른 해결 방안도 있다. 바로 두 코드를 하나로 묶어서 원자적으로 처리하는 것이다.

CAS 연산을 사용하면 두 연산을 하나로 묶어서 하나의 원자적인 연산으로 처리할 수 있다.

```java
public void lock() {
    log("락 획득 시도");
    while (!lock.compareAndSet(false, true)) {
        // 락을 획득할 때 까지 스핀 대기(바쁜 대기) 한다.
        log("락 획득 실패 - 스핀 대기");
    }
    log("락 획득 완료");
}
```

> 스핀락(Spin Lock)
> 
> 스핀 락 이라는 용어는, 락을 획득하기 위해 자원을 소모하면서 반복적으로 확인(스핀)하는 락 매커니즘을 의미한다.
> 
> 그리고 이런 스핀 락은 CAS를 사용해서 구현할 수 있다.

<br>

## CAS, Lock 방식 비교

### **Lock 방식**

- 데이터에 접근하기 전에 락을 획득
- 다른 스레드의 접근을 막음
- 비관적 접근법 → 다른 스레드가 방해할 것이다라고 가정

### **CAS 방식**

- 락을 사용하지 않고 데이터에 바로 접근
- 충돌이 발생하면 그때 재시도
- 낙관적 접근법 → 대부분의 경우 충돌이 없을것이다라고 가정

충돌이 많이 없는 경우에 CAS 연산이 빠른 것을 확인할 수 있다.

간단한 CPU연산은 너무 빨리 처리되기 때문에 충돌이 자주 발생하지 않는다. 충돌이 발생하기도 전에 이미 연산을 완료하는 경우가 더 많다.

정리하면 **간단한 CPU 연산에는 락 보다는 CAS를 사용하는 것이 효과적이다.**
