# Section 5. 스레드 제어와 생명주기 2

## 인터럽트

특정 스레드가 쉬고있을때, 처리해야할 작업이 들어와서 해당 스레드를 급하게 깨워야할때 사용할 수 있다.

인터럽트를 사용하면 `WAITING`, `TIMED_WATING` 같은 대기 상태의 스레드를 직접 깨워서 `RUNNABLE` 로 만들 수 있다.

- sleep() 메서드 실행중 스레드를 인터럽트 상태로 만들면 인터럽트 예외가 발생한다.
- 인터럽트 상태인 스레드가 sleep() 메서드를 만나면 인터럽트 예외가 발생한다.

sleep() 뿐만 아니라 InterruptedException을 발생하는 메서드는 모두 같은동작을 한다.

```java
while (true) { // 인터럽트 체크 안함
  log("작업 중");
  Thread.sleep(3000); // 여기서만 인터럽트 발생
}
```

while 조건문에서 인터럽트 상태 확인하는 코드를 넣으면 더 빨리 체크 가능

- Thread.isInterrupted() → 인터럽트 상태 확인 및 상태 변경 x
- Thread.interrupted() → 인터럽트 상태 확인 및 상태 변경 o

인터럽트 체크 후에 상태를 false로 변경해줘야지 다른 로직에서 또 예외를 잡지 않는다.

(예를 들어 인터럽트가 발생해서 자원정리를 하는데 sleep이 들어가있을경우에 인터럽트 상태가 그대로 true이면 자원 정리를 실패한다.)

<br>

## 프린터

메인스레드와 printer 스레드가 동시에 queue와 work에 접근해서 수정하므로 동시성을 처리할 수 있는 `volatile`과 `ConcurrentLinkedQueue<>` 를 사용해야한다

<br>

## yield - 양보하기

sleep(1)을 사용해서 스레드의 상태를 1밀리초 동안 아주 잠깐 `RUNNABLE` → `TIMED_WAITING` 으로 변경한다.

이렇게 되면 스레드는 CPU 자원을 사용하지 않고, 실행 스케줄링에서 잠시 제외된다.

하지만 이 방식은 `RUNNABLE` → `TIMED_WAITING` → `RUNNABLE`로 변경되는 복잡한 과정을 거치고, 또 특정 시간만큼 스레드가 실행되지 않는 단점이 있다.

나머지 스레드가 모두 대기상태로 쉬고 있어도 내 스레드까지 잠깐 실행되지 않는다. 쉽게 이야기 해서 양보할 사람이 없는데 혼자서 양보한 상황이 될 수 있다.

이럴때 yield를 사용할 수 있다.

자바의 스레드가 `RUNNABLE` 상태일 때, 운영체제의 스케줄링은 다음과 같은 상태들을 가질 수 있다.

- 실행 상태(Running) : 스레드가 CPU에서 실제로 실행 중이다.
- 실제 대기 상태(Ready) : 스레드가 실행될 준비가 되었지만, CPU가 바빠서 스케줄링 큐에서 대기 중이다.

참고로 자바에서는 두 상태를 구분할 수는 없다. 둘다 모두 `RUNNABLE`로 나타난다.

### **yield()의 작동**

- 현재 실행 중인 스레드가 자발적으로 CPU를 양보하여 다른 스레드가 실행될 수 있도록 한다.
- yield() 메서드를 호출한 스레드는 RUNNABLE 상태를 유지하면서 CPU를 양보한다.
    - 운영체제 스케줄링 상태에서 Running → Ready로 바뀐다고 생각

yield()는 `RUNNABLE` 상태를 유지하기 때문에, 양보할 사람이 없다면 본인 스레드가 계속 실행될 수 있다.
