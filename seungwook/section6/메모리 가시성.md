# Section 6. 메모리 가시성

## volatile

자바에서 volatile 키워드는 변수의 값을 읽거나 쓸 때 항상 메인 메모리에서 직접 접근하도록 강제하는 키워드이다. 이를 통해 멀티스레드 환경에서 발생할 수 있는 메모리 가시성 문제를 해결할 수 있다.


### 메모리 가시성 문제

멀티스레드 환경에서 한 스레드가 변경한 값이 다른 스레드에서 언제 볼 수 있는지에 대한 문제를 의미한다. 이 문제는 여러 스레드가 각각 자신의 캐시 메모리를 사용하기 때문에 발생할 수 있다.

![Image](https://github.com/user-attachments/assets/ea010266-20f2-46af-9311-54e470586356)

- main 스레드와 work 스레드는 각각 별도의 캐시 메모리를 사용
- main 스레드가 변수 값을 변경했더라도, work 스레드가 여전히 자신의 캐시 메모리에 저장된 이전 값을 참조한다면 서로 다른 값을 보게 된다.

보통 컨텍스트 스위칭 시점에 갱신되지만 이것이 갱신을 보장하는 것은 아니므로 메모리 가시성 문제를 해결하기 위해서는 volatile 키워드를 사용해줘야 한다.

캐시 메모리를 사용하면 CPU 처리 성능을 개선할 수 있지만 여러 스레드에서 같은 시점에 정확히 같은 데이터를 보는 것이 더 중요할 수 있다.

<br>

## 자바 메모리 모델 (Java memory model)

JMM은 자바 프로그램이 어떻게 메모리에 접근하고 수정할 수 있는지를 규정하며, 특히 멀티스레드 프로그래밍에서 스레드 간의 상호작용을 정의한다.

JMM에 여러가지 내용이 있지만, 핵심은 여러 스레드들의 작업 순서를 보장하는 happens-before 관계에 대한 정의다.

## happens-before

happens-before 관계는 자바 메모리 모델에서 스레드 간의 작업 순서를 정의하는 개념이다.

만약 A 작업이 B 작업보다 happens-before 관계에 있다면, A 작업에서의 모든 메모리 변경사항은 B 작업에서 볼 수 있다. 

즉, A 작업에서 변경된 내용은 B 작업이 시작되기 전에 모두 메모리에 반영된다.

- 스레드 간의 메모리 가시성을 보장하는 규칙이다.
- 그냥 보장되는게 아니라 volatile 같은 키워드를 넣어야 happens-before이 보장된다.
