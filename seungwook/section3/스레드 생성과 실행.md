# Section 3. 스레드 생성과 실행

Java에서 `Thread` 객체의 **`run()`** 메서드와 **`start()`** 메서드의 차이는

### `run()` 메서드

- **직접 호출하면 일반 메서드처럼 실행됩니다.**
- 새로운 스레드를 생성하지 않고 **현재 호출한 스레드에서 실행**됩니다.

### `start()` 메서드

- **새로운 스레드를 생성**하고, 해당 스레드에서 **`run()` 메서드를 비동기적으로 실행**합니다.
- 이 메서드를 호출해야만 Java의 멀티스레드 동작이 시작됩니다.

## 데몬스레드

스레드는 사용자스레드와 데몬 스레드 2가지로 구분된다

### 사용자 스레드

- 모든 user 스레드가 종료되면 jvm도 종료된다
- 작업이 완료될때까지 실행

### 데몬 스레드

- 백그라운드에서 보조적인 작업을 수행한다
- 모든 user 스레드가 종료되면 데몬 스레드는 자동으로 종료된다.

## 스레드 생성 - Runnable

스레드를 만들때는 Thread 클래스를 상속 받는 방법과 Runnable 인터페이스를 구현하는 방법이 있다

둘중에서는 실무에서 거의 runnable을씀

그러나 실무에서는 Executor 프레임워크 씀 → 스레드를 직접 만들지 않고 스레드 풀로 관리해서 더 효율적

| **특징** | **Thread/Runnable 직접 생성** | **스레드 풀(Thread Pool)** |
| --- | --- | --- |
| **스레드 생성 및 소멸 비용** | 작업마다 새로 생성 및 소멸, 비용 높음 | 미리 생성된 스레드를 재사용, 비용 절감 |
| **스레드 개수 제한** | 직접 제어 어려움 | 최대 스레드 수를 쉽게 제한 가능 |
| **작업 대기** | 작업을 대기열에 넣는 구조가 없음 | 작업 큐(Task Queue)를 통해 작업 대기 가능 |
| **리소스 사용 효율** | 스레드 과다 생성 시 자원 고갈 가능 | 자원을 효율적으로 사용하며 안정성 높음 |
| **코드 가독성 및 관리 용이성** | 스레드 관리와 예외 처리를 직접 구현해야 함 | API로 간단하게 관리 가능 |
| **실용성** | 간단한 테스트나 소규모 프로젝트에서 사용 가능 | 실무 및 고성능 애플리케이션에서 필수적 |
